# TapIn System – Full-Stack DevOps Project

**TapIn** is a full-stack RFID access management system designed to showcase end-to-end DevOps automation and software engineering skills. It allows students to **"tap in"** with their ID cards and verifies their training credentials to grant access to a facility. The entire project, from infrastructure to application, was designed and implemented by a single developer to demonstrate comprehensive ownership of a complex system.

## Features and Technologies

* **Infrastructure as Code**: Automated provisioning using **HashiCorp Packer** (image building), **Vagrant** (VM orchestration), and **Terraform** (cloud infrastructure configuration).
* **Consistent Dev Environment**: Containerized development setup with **Docker DevContainers**, ensuring a uniform environment for all developers and eliminating "works on my machine" issues.
* **Secure Secrets Management**: Centralized secrets via **HashiCorp Vault**, with dynamic injection of credentials (no hard-coded passwords) for services like databases.
* **Backend API (FastAPI)**: A Python FastAPI server providing RESTful endpoints, including a custom middleware for JWT-based authentication to secure API routes.
* **Frontend (Express & Electron)**: A **Node.js/Express** application as the web front-end and an **Electron** desktop app for a kiosk interface – both delivering a seamless user experience for tapping in.
* **Reverse Proxy & Load Balancing**: **Nginx** configured for route-based proxying to back-end services and **sticky sessions** to maintain session affinity for users.
* **Automation Scripts**: Custom Bash scripts to automate build, test, and deployment workflows, integrating all tools into a smooth CI/CD pipeline.

## Architecture Overview

The TapIn system follows a microservice-inspired architecture with full DevOps integration. Major components include:

* **Packer & Terraform for IaC** – All servers and infrastructure are defined as code. Packer is used to create a consistent base machine image (a "golden image") for the application servers. Terraform then provisions the infrastructure using this image, configuring servers, networks, and other resources in a declarative manner. This ensures any environment (development, testing, production) can be reproduced reliably from source control. Vagrant ties into this process by using the same Packer-built image to spin up local VMs, so the developer’s local environment mirrors production.

* **DevContainers for Development** – For day-to-day development, the project uses Visual Studio Code DevContainers (Docker-based development environments). The repository’s `.devcontainer` setup defines a Docker image with all necessary tools (Python, Node, Terraform, etc.), so that launching the dev environment is as simple as opening VS Code. This approach provides a **consistent and isolated setup** on any machine, avoiding configuration drift. A new developer can clone the repo and immediately have an identical development environment, improving productivity and onboarding.

* **HashiCorp Vault for Secrets** – Sensitive configuration (database credentials, API keys, JWT signing secrets, etc.) are stored and managed in Vault. The FastAPI backend at runtime requests credentials from Vault instead of using any static secrets. For example, the database user/password can be dynamically generated by Vault’s database secrets engine, so each application instance gets its own short-lived credentials. This **dynamic secrets** approach means there are no long-lived passwords in config files or code. Vault’s integration ensures that secrets are loaded on-the-fly and can be rotated or revoked centrally, greatly enhancing security. Vault policies control access, and only the appropriate services have permission to read the secrets they need.

* **FastAPI Backend with JWT Auth** – The core server-side logic is a FastAPI application in Python. It exposes REST endpoints for tap-in actions (e.g. an endpoint to submit an ID tap, which then checks the student’s training record in the database), as well as administrative endpoints (for managing training records, etc.). To secure these APIs, a **custom JWT authentication middleware** intercepts requests and verifies the presence of a valid JSON Web Token. This middleware ensures that protected endpoints can only be accessed with a token signed by the server (or Vault-stored secret) and not expired. By implementing JWT validation at the middleware layer, the solution provides stateless authentication – once a user is logged in and has a token, each request is self-authenticated, which is ideal for scaling and decoupling services. The JWT middleware was custom-built to fit this project’s needs, demonstrating a deep understanding of FastAPI’s internals (beyond basic usage). It checks for a bearer token in the HTTP headers, validates signature and claims (issuer, audience, expiration), and rejects unauthorized requests with proper HTTP responses. This design provides robust security for the backend without relying on external libraries for auth, underscoring the developer’s ability to implement security mechanisms from scratch.

* **Node.js/Express Frontend** – On the front-end side, the project includes a Node.js application using the Express framework. This service acts as a web frontend and API gateway for client interactions. The Express app can serve a web-based dashboard for staff or users: for instance, a webpage to display the status when a student taps in, or to allow an admin to search entries. It also can provide endpoints that the Electron app calls locally. The choice of Node/Express showcases skill in JavaScript and building server-side rendered pages or lightweight APIs to complement the Python backend. The Express frontend is integrated with the backend via HTTP APIs – it proxies or forwards certain calls to the FastAPI service or uses a shared database, depending on the route, ensuring a seamless integration between the two technologies. By building both a Python and a Node service, the project demonstrates polyglot development and the ability to choose the right tool for each component.

* **Electron Desktop Application** – In addition to the web interface, TapIn features an Electron-based desktop app. This app provides a kiosk-style interface on a dedicated machine (for example, a tablet or PC at the entry of the Idea Shop). Electron allows the use of web technologies (HTML/CSS/JS) to create a cross-platform desktop application. In TapIn, the Electron app presents a simple GUI for students to tap their IDs and see the result (allowed or denied) in real-time. Under the hood, the Electron app likely interacts with the Express server or directly with the FastAPI API to send the card swipe data and retrieve the validation result. By packaging the frontend in Electron, the project showcases the ability to deliver a native-feeling application that can integrate with hardware (like a card reader device via Node libraries) and still leverage the same backend. The Electron app demonstrates full-stack capability extending beyond web into desktop software distribution.

* **Nginx Reverse Proxy and Load Balancer** – Sitting in front of the FastAPI and Express services is an Nginx server configured as a reverse proxy. Nginx routes incoming requests to the correct service based on the URL path or subdomain. For example, API calls hitting `/api/...` can be forwarded to the FastAPI backend, while web requests for the frontend go to the Express server. This decoupling means internal service details stay hidden from the client, and everything appears under one unified endpoint. Nginx is also set up with **load balancing** in mind: if there were multiple instances of the backend services, Nginx would distribute requests among them (using round-robin or other algorithms). In this project, **sticky session** support is enabled to ensure session persistence. Sticky sessions (achieved via Nginx’s `ip_hash` or similar) mean that a returning user’s requests consistently go to the same backend instance, which can be crucial if that service holds session-specific data in memory. Even though JWT makes the backend stateless, the Express frontend might maintain a session or there might be performance reasons to keep a user pinned to one server. Nginx’s configuration in TapIn demonstrates knowledge of advanced web server configs – from reverse proxying multiple services to enabling SSL (if applicable) and tuning session affinity for stateful interactions. This contributes to a production-grade deployment setup where scaling out is as simple as running more instances behind Nginx.

* **Database and Data Management** – (Under the hood, the system uses a relational database to store user training records and tap-in logs. **Infrastructure** code likely provisions a database instance or container as part of the Terraform scripts, and the backend interacts with it securely. HashiCorp Vault provides the database credentials dynamically to the app, as mentioned. The FastAPI server includes data models (possibly using an ORM or direct queries) to read/write the necessary data. All schema changes or queries are handled in code or migration scripts, keeping with the infrastructure-as-code philosophy for database setup as well. **Note:** This is implied from context; the actual implementation includes a `database/` directory in the repository, indicating scripts or configuration for the database.)

* **Automation & CI/CD** – To glue all these parts together, the project provides numerous Bash scripts for automation. Rather than manually running Packer or Terraform with long commands, a developer can run a single script (e.g., `./build_image.sh`) to execute Packer with the correct parameters, or `./deploy_infra.sh` to apply Terraform configurations. Other scripts handle running test suites (for backend Python tests or perhaps frontend tests) and building/deploying the Node and Python applications (possibly containerizing them or uploading binaries). These scripts can be invoked directly by a developer or hooked into a Continuous Integration pipeline. In fact, the repository includes GitHub Actions workflows (`.github/workflows`) which likely call these scripts on each push – for instance, to run linting, unit tests, and even deploy to a test environment. This scripting demonstrates **DevOps automation** proficiency: any repetitive task is codified, ensuring consistent results and saving time. For example, setting up a new VM might involve provisioning, configuring environment variables (like Vault addresses or keys), and starting services – all of which can be done by a single automated script to avoid human error. The presence of these scripts shows foresight in making the project easy to build and launch, which is crucial in real-world engineering where continuous delivery is valued.

## Conclusion

The **TapIn System** project is a comprehensive demonstration of DevOps and full-stack engineering capabilities. It integrates a wide range of technologies – from infrastructure provisioning and containerization to backend API development and front-end interface design – in one cohesive system. Every layer of the stack follows best practices (infrastructure-as-code, containerized dev environments, secure secret management, stateless auth, etc.), reflecting a production-oriented mindset.
